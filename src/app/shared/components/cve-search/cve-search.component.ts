import { HttpClient } from '@angular/common/http';
import { Component, OnInit, Optional, ViewChild } from '@angular/core';
import { DataService } from '../../../util/data.service';
import { ThemeService } from '../../../util/theme.service';
import { animate, state, style, transition, trigger } from '@angular/animations';
import { ICVEEntry, ICVEEntryUtil } from '../cve-entry/cve-entry.component';
import { MatPaginator } from '@angular/material/paginator';
import { MatSort } from '@angular/material/sort';
import { MatTableDataSource } from '@angular/material/table';
import { ViewElementBase } from '../../../model/database';
import { DialogService, MyString } from '../../../util/dialog.service';
import { LocalStorageService, LocStorageKeys } from '../../../util/local-storage.service';
import { ICVSSEntry, ImpactCategories } from '../../../model/threat-model';

@Component({
  selector: 'app-cve-search',
  templateUrl: './cve-search.component.html',
  styleUrls: ['./cve-search.component.scss'],
  animations: [
    trigger('detailExpand', [
      state('collapsed', style({height: '0px', minHeight: '0'})),
      state('expanded', style({height: '*'})),
      transition('expanded <=> collapsed', animate('225ms cubic-bezier(0.4, 0.0, 0.2, 1)')),
    ]),
  ]
})
export class CveSearchComponent implements OnInit {
  private element: ViewElementBase;
  private viewID: string;
  private searchHistory;

  constructor(@Optional() element: ViewElementBase, @Optional() viewID: MyString, public theme: ThemeService, public dataService: DataService, 
  private dialog: DialogService, private locStorage: LocalStorageService, private http: HttpClient) { 
    if (element) this.element = element;
    if (viewID) this.viewID = viewID.Value;
  }
  
  @ViewChild(MatSort) sort: MatSort;
  @ViewChild(MatPaginator) paginator: MatPaginator;

  public SearchString: string = '';
  public ExactSearch: boolean = false;
  public NoSearchResult = false;

  public dataSource: MatTableDataSource<ICVEEntry>;
  public columnsToDisplay = ['add', 'id', 'published', 'vulnStatus', 'score'];
  public columnsToDisplayWithExpand = [...this.columnsToDisplay, 'expand'];
  public expandedElement;

  ngOnInit(): void {
    const history = this.locStorage.Get(LocStorageKeys.CVE_SEARCH_HISTORY);
    if (history == null) {
      this.searchHistory = {};
      this.locStorage.Set(LocStorageKeys.CVE_SEARCH_HISTORY, JSON.stringify(this.searchHistory));
    }
    else if (this.element && this.viewID) {
      this.searchHistory = JSON.parse(history);
      const lastSearch = this.searchHistory[this.element.ID + this.viewID];
      if (lastSearch) {
        this.SearchString = lastSearch;
        this.Search();
      }
    }
  }

  public Search() {
    if (this.SearchString?.length > 0) {
      this.http.get('https://services.nvd.nist.gov/rest/json/cves/2.0?keywordSearch=' + this.SearchString).subscribe(res => {
        //console.log(res);
        this.searchHistory[this.element.ID + this.viewID] = this.SearchString;
        this.locStorage.Set(LocStorageKeys.CVE_SEARCH_HISTORY, JSON.stringify(this.searchHistory));
        if (res['vulnerabilities']?.length > 0) {
          const newArray = [];
          res['vulnerabilities'].forEach(cve => {
            if (cve['cve']) newArray.push(ICVEEntryUtil.FromJSON(cve['cve']));
            if (Object.keys(cve).length > 1) console.log('what?', cve);
          });
          newArray.reverse();
          this.dataSource = new MatTableDataSource(newArray);
          this.dataSource.sort = this.sort;
          this.dataSource.paginator = this.paginator;
          this.NoSearchResult = newArray.length == 0;
        }
        else {
          this.dataSource = new MatTableDataSource([]);
          this.dataSource.paginator = this.paginator;
          this.NoSearchResult = true;
        }
      });
    }
  }

  public AddThreat(entry: ICVEEntry) {
    if (this.element && this.viewID) {
      let as = this.dataService.Project.CreateAttackScenario(this.viewID, false);
      // check threat cats
      const cats = [];
      if (entry.Scores.length > 0) {
        const stride = this.dataService.Config.GetThreatCategoryGroups().find(x => x.Name == 'STRIDE');
        if (stride) {
          const scores: ICVSSEntry[] = JSON.parse(JSON.stringify(entry.Scores));
          scores.sort((a, b) => b.Version.localeCompare(a.Version));
          const vec = scores[0].Vector;
          if (vec[vec.indexOf('/C:')+3] != 'N') cats.push(stride.ThreatCategories.find(x => x.ImpactCats.includes(ImpactCategories.Confidentiality)).ID);
          if (vec[vec.indexOf('/I:')+3] != 'N') cats.push(stride.ThreatCategories.find(x => x.ImpactCats.includes(ImpactCategories.Integrity)).ID);
          if (vec[vec.indexOf('/A:')+3] != 'N') cats.push(stride.ThreatCategories.find(x => x.ImpactCats.includes(ImpactCategories.Availability)).ID);
        }
      }
      
      as.SetMapping('', cats, this.element, [this.element], null, null, null, null);
      as.Description = entry.Description;
      as.Name = entry.ID; 
      as.CveEntry = entry;
      if (entry.Severities) as.Severity = Math.max(...entry.Severities);
      if (entry.Scores.some(x => x.Version.startsWith('3.'))) as.ScoreCVSS = JSON.parse(JSON.stringify(entry.Scores.find(x => x.Version.startsWith('3.'))));
      as.IsGenerated = false;
      this.dialog.OpenAttackScenarioDialog(as, true).subscribe(result => {
        if (!result) {
          this.dataService.Project.DeleteAttackScenario(as);
        }
      });
    }
  }

  public SearchKeyUp(event: KeyboardEvent) {
    if (event.key == 'Enter') this.Search();
  }

  public GetScore(entry: ICVEEntry) {
    if (entry.Scores?.length > 0) {
      return Math.max(...entry.Scores.map(x => x.Score).filter(x => x != null)).toString();
    }
    return '';
  }
}
